import { __awaiter, __generator } from "tslib";
import { isOffline } from '../../core/connection';
import { PriorityQueue } from '../../lib/priority-queue';
import { PersistedPriorityQueue } from '../../lib/priority-queue/persisted';
import { toFacade } from '../../lib/to-facade';
import batch from './batched-dispatcher';
import standard from './fetch-dispatcher';
import { normalize } from './normalize';
import { scheduleFlush } from './schedule-flush';
import { SEGMENT_API_HOST } from '../../core/constants';
import { clientHints } from '../../lib/client-hints';
function onAlias(analytics, json) {
    var _a, _b, _c, _d;
    var user = analytics.user();
    json.previousId =
        (_c = (_b = (_a = json.previousId) !== null && _a !== void 0 ? _a : json.from) !== null && _b !== void 0 ? _b : user.id()) !== null && _c !== void 0 ? _c : user.anonymousId();
    json.userId = (_d = json.userId) !== null && _d !== void 0 ? _d : json.to;
    delete json.from;
    delete json.to;
    return json;
}
export function segmentio(analytics, settings, integrations) {
    var _a, _b, _c;
    return __awaiter(this, void 0, void 0, function () {
        function send(ctx) {
            return __awaiter(this, void 0, void 0, function () {
                var path, json;
                return __generator(this, function (_a) {
                    if (isOffline()) {
                        buffer.push(ctx);
                        // eslint-disable-next-line @typescript-eslint/no-use-before-define
                        scheduleFlush(flushing, buffer, segmentio, scheduleFlush);
                        return [2 /*return*/, ctx];
                    }
                    inflightEvents.add(ctx);
                    path = ctx.event.type.charAt(0);
                    if (userAgentData && ctx.event.context) {
                        ctx.event.context.userAgentData = userAgentData;
                    }
                    json = toFacade(ctx.event).json();
                    if (ctx.event.type === 'track') {
                        delete json.traits;
                    }
                    if (ctx.event.type === 'alias') {
                        json = onAlias(analytics, json);
                    }
                    return [2 /*return*/, client
                            .dispatch("".concat(remote, "/").concat(path), normalize(analytics, json, settings, integrations))
                            .then(function () { return ctx; })
                            .catch(function () {
                            buffer.pushWithBackoff(ctx);
                            // eslint-disable-next-line @typescript-eslint/no-use-before-define
                            scheduleFlush(flushing, buffer, segmentio, scheduleFlush);
                            return ctx;
                        })
                            .finally(function () {
                            inflightEvents.delete(ctx);
                        })];
                });
            });
        }
        var writeKey, buffer, inflightEvents, flushing, apiHost, protocol, remote, deliveryStrategy, client, userAgentData, _d, segmentio;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    // Attach `pagehide` before buffer is created so that inflight events are added
                    // to the buffer before the buffer persists events in its own `pagehide` handler.
                    window.addEventListener('pagehide', function () {
                        buffer.push.apply(buffer, Array.from(inflightEvents));
                        inflightEvents.clear();
                    });
                    writeKey = (_a = settings === null || settings === void 0 ? void 0 : settings.apiKey) !== null && _a !== void 0 ? _a : '';
                    buffer = analytics.options.disableClientPersistence
                        ? new PriorityQueue(analytics.queue.queue.maxAttempts, [])
                        : new PersistedPriorityQueue(analytics.queue.queue.maxAttempts, "".concat(writeKey, ":dest-Segment.io"));
                    inflightEvents = new Set();
                    flushing = false;
                    apiHost = (_b = settings === null || settings === void 0 ? void 0 : settings.apiHost) !== null && _b !== void 0 ? _b : SEGMENT_API_HOST;
                    protocol = (_c = settings === null || settings === void 0 ? void 0 : settings.protocol) !== null && _c !== void 0 ? _c : 'https';
                    remote = "".concat(protocol, "://").concat(apiHost);
                    deliveryStrategy = settings === null || settings === void 0 ? void 0 : settings.deliveryStrategy;
                    client = (deliveryStrategy === null || deliveryStrategy === void 0 ? void 0 : deliveryStrategy.strategy) === 'batching'
                        ? batch(apiHost, deliveryStrategy.config)
                        : standard(deliveryStrategy === null || deliveryStrategy === void 0 ? void 0 : deliveryStrategy.config);
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, clientHints(analytics.options.highEntropyValuesClientHints)];
                case 2:
                    userAgentData = _e.sent();
                    return [3 /*break*/, 4];
                case 3:
                    _d = _e.sent();
                    userAgentData = undefined;
                    return [3 /*break*/, 4];
                case 4:
                    segmentio = {
                        name: 'Segment.io',
                        type: 'after',
                        version: '0.1.0',
                        isLoaded: function () { return true; },
                        load: function () { return Promise.resolve(); },
                        track: send,
                        identify: send,
                        page: send,
                        alias: send,
                        group: send,
                        screen: send,
                    };
                    // Buffer may already have items if they were previously stored in localStorage.
                    // Start flushing them immediately.
                    if (buffer.todo) {
                        scheduleFlush(flushing, buffer, segmentio, scheduleFlush);
                    }
                    return [2 /*return*/, segmentio];
            }
        });
    });
}
//# sourceMappingURL=index.js.map